<!DOCTYPE html>
<html>
<head>
    <title>LayersControl Sample Usage</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@4.1.1/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@4.1.1/dist/maplibre-gl.css" rel="stylesheet">
    
    <!-- Deck.GL -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/deck.gl@9.1.14/dist/stylesheet.min.css">
    <script src="https://cdn.jsdelivr.net/npm/deck.gl@9.1.14/dist.min.js"></script>
    
    <!-- Your LayersControl -->
    <link href="./src/css/uiManager.css" rel="stylesheet">
    
    <script src="./src/js/helper.js"></script>
    <script src="./src/js/stateManager.js"></script>
    <script src="./src/js/uiManager.js"></script>
    <script src="./src/js/layersControl.js"></script>

    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <script>
        // Sample data for overlays
        const samplePoints = [
            { position: [-74.006, 40.7128], name: "Times Square", color: [255, 0, 0] },
            { position: [-74.0445, 40.6892], name: "Statue of Liberty", color: [0, 255, 0] },
            { position: [-73.9857, 40.7484], name: "Empire State Building", color: [0, 0, 255] },
            { position: [-73.9776, 40.7831], name: "Central Park", color: [255, 255, 0] }
        ];

        const sampleLines = [
            {
                path: [
                    [-74.006, 40.7128],
                    [-74.0445, 40.6892],
                    [-73.9857, 40.7484]
                ],
                name: "Tourist Route",
                color: [255, 100, 100]
            }
        ];

        const baseStyles = [
            {
                id: 'streets',
                label: 'Streets',
                strategy: 'setStyle',
                style: 'https://demotiles.maplibre.org/style.json'
            },
            {
                id: 'satellite',
                label: 'Satellite',
                strategy: 'setStyle', 
                style: {
                    version: 8,
                    sources: {
                        'satellite': {
                            type: 'raster',
                            tiles: [
                                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
                            ],
                            tileSize: 256
                        }
                    },
                    layers: [
                        {
                            id: 'satellite',
                            type: 'raster',
                            source: 'satellite'
                        }
                    ]
                }
            }
        ];

        const overlays = [
            // Simple Deck.GL ScatterplotLayer
            {
                id: 'points',
                label: 'Sample Points',
                defaultVisible: true,
                opacityControls: true,
                defaultOpacity: 0.8,
                deckLayers: [
                    {
                        id: 'points-layer',
                        type: 'ScatterplotLayer',
                        props: {
                            data: samplePoints,
                            getPosition: d => d.position,
                            getFillColor: d => d.color,
                            getRadius: 50,
                            radiusMinPixels: 3,
                            radiusMaxPixels: 20,
                            pickable: true
                        }
                    }
                ],
                onChecked: (context) => {
                    console.log('Overlay activated!', context.overlayId);
                    console.log('User interaction?', context.isUserInteraction);
                    console.log('Current zoom:', context.getCurrentViewport().zoom);
                },
                onUnchecked: (context) => {
                    console.log('Overlay deactivated!', context.overlayId);
                },
                tooltip: {
                    title: 'name',
                    fields: [
                        { label: 'Location', property: 'name' },
                        { label: 'Coordinates', property: 'position' }
                    ]
                }
            },

            // PathLayer for lines
            {
                id: 'routes',
                label: 'Routes',
                group: 'Navigation',
                defaultVisible: false,
                opacityControls: true,
                deckLayers: [
                    {
                        id: 'routes-layer',
                        type: 'PathLayer',
                        props: {
                            data: sampleLines,
                            getPath: d => d.path,
                            getLineColor: d => d.color,
                            getWidth: 20,
                            pickable: true
                        }
                    }
                ],
                tooltip: 'name'
            },

            // Dynamic data loading example using new onChecked API
            {
                id: 'dynamic-data',
                label: 'Dynamic Points',
                group: 'Dynamic',
                defaultVisible: false,
                opacityControls: true,
                onChecked: async (context) => {
                    // Check cache first
                    const viewport = context.getCurrentViewport();
                    
                    let cachedData = context.getCache();
                    if (cachedData) {
                        console.log('Using cached dynamic data');
                        context.setOverlayConfig({
                            deckLayers: cachedData.deckLayers,
                            label: `Dynamic Points (${cachedData.count} cached)`
                        });
                        return;
                    }
                    
                    // Simulate API call
                    console.log('Loading dynamic data...', context);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Generate random points around current map center
                    const center = context.map.getCenter();
                    const randomPoints = Array.from({ length: 10 }, (_, i) => ({
                        position: [
                            center.lng + (Math.random() - 0.5) * 0.02,
                            center.lat + (Math.random() - 0.5) * 0.02
                        ],
                        name: `Dynamic Point ${i + 1}`,
                        color: [Math.random() * 255, Math.random() * 255, Math.random() * 255]
                    }));

                    const deckLayers = [
                        {
                            id: 'dynamic-points-layer',
                            type: 'ScatterplotLayer',
                            props: {
                                data: randomPoints,
                                getPosition: d => d.position,
                                getFillColor: d => d.color,
                                getRadius: 30,
                                radiusMinPixels: 5,
                                radiusMaxPixels: 15
                            }
                        }
                    ];

                    // Cache the result
                    context.setCache({ deckLayers, count: randomPoints.length });

                    // Update overlay configuration
                    context.setOverlayConfig({
                        deckLayers: deckLayers,
                        label: `Dynamic Points (${randomPoints.length} loaded)`,
                        tooltip: {
                            title: 'name',
                            fields: [
                                { label: 'Position', property: 'position' }
                            ]
                        }
                    });
                }
            },

            // Layer with zoom constraints
            {
                id: 'detailed-markers',
                label: 'Detailed Markers (Zoom > 14)',
                group: 'Detail',
                filter: {
                    minZoom: 14
                },
                defaultVisible: false,
                deckLayers: [
                    {
                        id: 'detailed-markers-layer',
                        type: 'ScatterplotLayer',
                        props: {
                            data: samplePoints,
                            getPosition: d => d.position,
                            getFillColor: [255, 255, 255],
                            getRadius: 20,
                            stroked: true,
                            getLineColor: [0, 0, 0],
                            getLineWidth: 20
                        }
                    }
                ]
            },

            // Layer with forced viewport changes
            {
                id: 'central-park-view',
                label: 'Central Park (3D View)',
                group: 'Views',
                viewport: {
                    pitch: 45,
                    bearing: 30,
                    fitBounds: [
                        [-73.9812, 40.7679], // Southwest corner of Central Park
                        [-73.9441, 40.8007]  // Northeast corner of Central Park
                    ]
                },
                deckLayers: [
                    {
                        id: 'park-boundary',
                        type: 'PathLayer',
                        props: {
                            data: [{
                                path: [
                                    [-73.9812, 40.7679],
                                    [-73.9441, 40.7679],
                                    [-73.9441, 40.8007],
                                    [-73.9812, 40.8007],
                                    [-73.9812, 40.7679]
                                ]
                            }],
                            getPath: d => d.path,
                            getLineColor: [0, 255, 0, 100],
                            getWidth: 30
                        }
                    }
                ]
            },

            // Example overlay with callbacks
            {
                id: 'callback-example',
                label: 'Callback Example Layer',
                group: 'Examples',
                defaultVisible: false,
                opacityControls: true,
                deckLayers: [
                    {
                        id: 'callback-example-layer',
                        type: 'ScatterplotLayer',
                        props: {
                            data: [
                                { position: [-74.0, 40.7], name: "Callback Point 1", color: [255, 0, 255] },
                                { position: [-74.01, 40.71], name: "Callback Point 2", color: [255, 0, 255] }
                            ],
                            getPosition: d => d.position,
                            getFillColor: d => d.color,
                            getRadius: 100,
                            radiusMinPixels: 5,
                            radiusMaxPixels: 25
                        }
                    }
                ],
                onChecked: (context) => {
                    console.log('ðŸŸ¢ Overlay checked!', {
                        overlayId: context.overlayId,
                        isUserInteraction: context.isUserInteraction,
                        currentZoom: context.getCurrentViewport().zoom,
                        overlayStates: context.getAllOverlayStates()
                    });
                },
                onUnchecked: (context) => {
                    console.log('ðŸ”´ Overlay unchecked!', {
                        overlayId: context.overlayId,
                        isUserInteraction: context.isUserInteraction,
                        currentZoom: context.getCurrentViewport().zoom
                    });
                }
            },

            // Advanced example showing zoom-aware dynamic configuration
            {
                id: 'adaptive-layer',
                label: 'Adaptive Data Layer',
                group: 'Advanced',
                defaultVisible: false,
                opacityControls: true,
                onChecked: async (context) => {
                    const viewport = context.getCurrentViewport();
                    const cacheKey = `adaptive_${viewport.zoom > 12 ? 'detailed' : 'summary'}`;
                    
                    // Check cache
                    let config = context.getCache(cacheKey);
                    if (config) {
                        console.log('Using cached adaptive configuration');
                        context.setOverlayConfig(config, { 
                            changedProperties: ['deckLayers', 'label'],
                            applyViewport: true 
                        });
                        return;
                    }
                    
                    // Create different configurations based on zoom level
                    if (viewport.zoom > 12) {
                        // High detail view
                        config = {
                            deckLayers: [
                                {
                                    id: 'detailed-adaptive-layer',
                                    type: 'TextLayer',
                                    props: {
                                        data: [
                                            { position: [-74.006, 40.7128], text: "Times Sq", size: 16 },
                                            { position: [-74.0445, 40.6892], text: "Liberty", size: 18 }
                                        ],
                                        getPosition: d => d.position,
                                        getText: d => d.text,
                                        getSize: d => d.size,
                                        getColor: [255, 255, 255]
                                    }
                                }
                            ],
                            label: 'Adaptive Layer (Detailed)',
                            viewport: {
                                pitch: 0,
                                bearing: 0
                            }
                        };
                    } else {
                        // Summary view with different viewport
                        config = {
                            deckLayers: [
                                {
                                    id: 'summary-adaptive-layer',
                                    type: 'ScatterplotLayer',
                                    props: {
                                        data: [
                                            { position: [-74.006, 40.7128], color: [255, 0, 0] },
                                            { position: [-74.0445, 40.6892], color: [0, 255, 0] }
                                        ],
                                        getPosition: d => d.position,
                                        getFillColor: d => d.color,
                                        getRadius: 500
                                    }
                                }
                            ],
                            label: 'Adaptive Layer (Summary)',
                            viewport: {
                                pitch: 45,
                                bearing: 30,
                                fitBounds: [
                                    [-74.1, 40.6], 
                                    [-73.9, 40.8]
                                ]
                            }
                        };
                    }
                    
                    // Cache and apply
                    context.setCache(cacheKey, config);
                    context.setOverlayConfig(config, { 
                        applyViewport: true 
                    });
                }
            },

            // Example demonstrating filter capabilities
            {
                id: 'zoom-filtered-overlay',
                label: 'Mid-Zoom Layer (Z: 8-15)',
                group: 'Advanced', 
                filter: {
                    minZoom: 8,
                    maxZoom: 15
                },
                defaultVisible: false,
                deckLayers: [
                    {
                        id: 'zoom-filtered-layer',
                        type: 'ScatterplotLayer',
                        props: {
                            data: [
                                { position: [-74.006, 40.7128], color: [255, 165, 0] },
                                { position: [-74.0445, 40.6892], color: [255, 165, 0] },
                                { position: [-73.9857, 40.7484], color: [255, 165, 0] }
                            ],
                            getPosition: d => d.position,
                            getFillColor: d => d.color,
                            getRadius: 100
                        }
                    }
                ]
            }
        ];

        // Create layers control with comprehensive configuration
        const layersControl = new LayersControl({
            // Base map styles
            baseStyles: baseStyles,

            // Overlay layers
            overlays: overlays,

            // Configuration options
            defaultBaseId: 'streets',
            autoClose: false,
            showOpacity: true,
            position: 'top-right',
            
            // Enable state persistence
            // persist: {
            //    localStorageKey: 'my-map-layers-state'
            // },

            // Internationalization
            i18n: (key) => {
                const translations = {
                    'layers': 'Map Layers',
                    'Base Maps': 'Base Maps',
                    'Overlays': 'Data Layers'
                };
                return translations[key] || key;
            },

            // Change event handler
            onChange: (state) => {
                console.log('Layer state changed:', state);
            }
        });

        const previousState = layersControl.stateManager.getAll();

        // Initialize the map
        const map = new maplibregl.Map({
            container: 'map',
            center: previousState.viewport.center || [0, 0],
            style: baseStyles.find(s => s.id === previousState.baseId)?.style || baseStyles[0].style,
            zoom: previousState.viewport.zoom || 1,
            pitch: previousState.viewport.pitch || 0,
            bearing: previousState.viewport.bearing || 0,
        });

        // Add control to map
        map.on('load', () => {
            // Use MapLibre's addControl method, not addTo()
            map.addControl(layersControl);
            
            // Example of programmatic control
            setTimeout(() => {
                console.log('Programmatically showing routes layer...');
                layersControl.showOverlay('routes');
            }, 3000);
        });

        // Fix the utility functions to use correct API methods
        window.clearMemory = () => {
            // Use the correct method name from the refactored API
            layersControl.clearPersistedData();
            console.log('Layer memory cleared!');
        };

        window.getCurrentState = () => {
            // Use the correct method name from the refactored API
            console.log('Current state:', layersControl.getCurrentState());
        };

        // Example event listeners
        layersControl.on('basechange', (data) => {
            console.log('Base map changed to:', data.baseId);
        });

        layersControl.on('overlaychange', (data) => {
            console.log('Overlay changed:', data.id, 'visible:', data.visible);
        });

        layersControl.on('error', (data) => {
            console.error('Layer error:', data);
        });

        layersControl.on('loading', (data) => {
            console.log('Layer loading:', data.id);
        });

        // Utility functions for dynamic layer management
        window.addRandomOverlay = () => {
            const id = `random-${Date.now()}`;
            const randomPoints = Array.from({ length: 5 }, (_, i) => ({
                position: [
                    -74.006 + (Math.random() - 0.5) * 0.05,
                    40.7128 + (Math.random() - 0.5) * 0.05
                ],
                color: [Math.random() * 255, Math.random() * 255, Math.random() * 255]
            }));

            layersControl.addOverlay({
                id: id,
                label: `Random Layer ${id.split('-')[1]}`,
                group: 'Dynamic',
                defaultVisible: true,
                opacityControls: true,
                deckLayers: [
                    {
                        id: `${id}-layer`,
                        type: 'ScatterplotLayer',
                        props: {
                            data: randomPoints,
                            getPosition: d => d.position,
                            getFillColor: d => d.color,
                            getRadius: 500
                        }
                    }
                ],
                onChecked: (context) => {
                    console.log(`âœ… Random layer ${id} was checked!`, {
                        fromUser: context.isUserInteraction,
                        pointCount: randomPoints.length,
                        currentZoom: context.getCurrentViewport().zoom
                    });
                },
                onUnchecked: (context) => {
                    console.log(`âŒ Random layer ${id} was unchecked!`, {
                        fromUser: context.isUserInteraction
                    });
                }
            });
        };

        window.clearMemory = () => {
            layersControl.clearPersistedData();
            console.log('Layer memory cleared!');
        };

        window.getCurrentState = () => {
            console.log('Current state:', layersControl.getCurrentState());
        };

        // Add some utility buttons for testing
        const controlsDiv = document.createElement('div');
        controlsDiv.style.cssText = 'position: absolute; top: 10px; left: 10px; z-index: 1000;';
        controlsDiv.innerHTML = `
            <button onclick="addRandomOverlay()" style="margin: 2px;">Add Random Overlay</button><br>
            <button onclick="layersControl.removeAllOverlays()" style="margin: 2px;">Remove All Overlays</button><br>
            <button onclick="getCurrentState()" style="margin: 2px;">Log Current State</button><br>
            <button onclick="clearMemory()" style="margin: 2px;">Clear Memory</button>
        `;
        document.body.appendChild(controlsDiv);

        // Example of using BoundsHelper utility
        const bounds = BoundsHelper.calculateBounds(
            samplePoints.map(p => p.position),
            0.01 // padding
        );
        console.log('Calculated bounds for sample points:', bounds);
    </script>
</body>
</html>